# 1. JPA 소개

JPA는 자바 진영의 ORM(Object Relational Mapping) 기술 표준

JPA는 지루하고 반복적인 CRUD SQL을 알아서 처리해주며, 객체 모델링과 관계형 데이터베이스 사이의 차이점 해결할 수 있음

JPA를 사용하면 객체 중심으로 개발 할 수 있기에 생산성과 유지보수가 좋아지고, 버그가 줄어들며 테스트를 작성하기에 편리함

# SQL을 직접 다룰 때 발생하는 문제점

회원을 CRUD하는 기능을 만든다고 한다고 가정

1. 회원 등록용 SQL을 작성
2. 회원 객체의 값을 꺼내서 등록 SQL에 전달
3. JDBC API를 사용하여 SQL 실행

객체를 데이터베이스에 직접 저장하거나 조회할 수 없기에 개발자가 객체지향 애플리케이션과 데이터베이스 중간에서 SQL과 JDBC API를 사용해서 변환 작업을 해야함

이 과정은 너무 지루하고 반복의 연속

뿐 만 아니라 칼럼을 추가하기 위해서는 정말 많이 연관된 코드들을 다 변경해야 함
<br/><br/>

**SQL을 직접 다룰 때 단점**

- 진정한 의미의 계층 분할이 어려움
- 엔티티를 신뢰할 수 없음
- SQL에 의존적인 개발을 피하기 어려움

⇒ JPA를 사용하면 이러한 문제들이 해결됨
<br/><br/><br/>

객체를 데이터베이스에 저장하고 관리할 때 직접 SQL을 작성하는 것이 아닌 JPA가 제공하는 API를 사용

=> 개발자 대신에 JPA가 적절한 SQL을 생성하여 데이터베이스에 전달
<br/><br/>

객체지향 프로그래밍은 추상화, 캡슐화, 정보은닉, 상속, 다형성 등 시스템의 복잡성을 제어할 수 있는 다양한 장치들을 제공
<br/><br/>

관계형 데이터베이스는 데이터 중심으로 구조화되고 집합적인 사고를 요구하며, 객체지향의 추상화, 상속, 다형성 같은 개념이 없음

⇒ 따라서 객체와 관계형 데이터베이스는 패러다임의 불일치 문제가 발생함
<br/>
  

# 패러다임의 불일치로 인해 발생하는 문제

## 상속

### SQL 사용할 시

각각의 객체를 분해하여 SQL문을 작성 후 각 테이블을 조인하여 조회하고, 그 결과로 새로운 객체를 생성해야하는 번거로운 과정을 거침

### JPA 사용할 시

패러다임의 불일치 문제를 개발자 대신 해결해주기에, 자바에서 하던 것 처럼 JPA에 객체를 저장

## 연관관계

- 객체
    - 참조를 사용해서 다른 객체와 연관관계를 가지고, 참조에 접근해서 연관된 객체를 조회
    - 참조가 있는 방향으로만 조회 가능
- 테이블
    - 외래 키를 사용해서 다른 테이블과 연관관계를 가지고 조인을 사용해서 연관된 테이블을 조회
    - 참조가 있는 방향 뿐만 아니라 반대 방향으로도 조회 가능

### SQL 사용할 시

참조를 사용하도록 모델링해야 함

참조를 필요로한 객체와는 다르게 테이블은 외래키만 있으면 되기에 개발자가 중간에서 변환해야함

### JPA 사용할 시

각 객체의 관계를 설정하고, 해당 객체룰 저장하면 됨

객체를 조회할 때 JPA가 외래키를 참조로 변환해줌

## 객체 그래프 탐색

객체 그래프 탐색이란 참조를 사용하여 연관된 객체를 조회하는 것

### SQL 사용할 시

SQL을 직접 다루면 처음 실행하는 sql에 따라 객체 그래프를 어디 까지 탐색할 지 정해짐

이는 객체지향 개발자에게 너무 큰 제약

코드만 보고는 어느 방향으로 어디까지 연관된 객체를 탐색할 수 있지 않을지 모름

직접 SQL문을 봐야 알 수 있음

이는 엔티티가 SQL에 논리적으로 종속되어서 발생하는 문제

### JPA 사용할 시

JPA는 연관된 객체를 사용하는 시점에 적절한 SELECT SQL을 실행하기에 연관된 객체를 신뢰하고 마음껏 조회할 수 있음

**지연로딩** : 실제 객체를 사용하는 시점까지 데이터베이스 조회를 미룸

JPA는 지연 로딩을 투명하게 처리

JPA는 연관된 객체를 즉시 함께 조회할 지 아니면 실제 사용하는 시점에 지연해서 조회할지를 간단한 설정으로 정의할 수 있음

# 비교

데이터베이스는 기본 키의 값으로 각 row를 구분

객체는 동일성(identity) 비교와 동등성(equality) 비교라는 두 가지 비교 방법이 있음

- 동일성 비교
    - ==를 사용하여 객체 인스턴스의 주소 값을 비교
- 동등성 비교
    - equals() 메소드를 사용하여 객체 내부의 값을 비교

### SQL 사용할 시

SQL에서는 기본키 값이 같은 객체를 2번 조회했을 때 동일성(==) 비교시 인스턴스가 다르기 때문에 false 반환

하지만 데이터베이스에서는 객체의 동일성 비교에 실패

### JPA 사용할 시

JPA는 같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장

 

# jpa란 무엇인가

Java Persistence API의 약자로 자바 진영의 ORM 기술 표준

애플리케이션과 JDBC 사이에서 동작
<br/><br/>

ORM은 Object-Reational Mapping의 약자로 객체와 관계형 데이터베이스를 매핑한다는 뜻

ORM 프레임워크는 객체와 테이블을 매핑해서 패러다임의 불일치 문제를 개발자 대신 해결해줌

패러다임의 불일치 문제도 해결

⇒ 객체 측면에서는 정교한 모델링을 할 수 잇고, 관계형 데이터베이슨는 데이터베이스에 맞도록 모델링 하면 됨
<br/><br/>

많은 프레임워크가 있는데 하이버네이트 프레임워크가 가장 많이 사용됨

거의 대부분의 패러다임 불일치 문제를 해결해주는 성숙한 ORM 프레임워크
<br/><br/>

JPA는 자바 ORM 기술에 대한 API 표준 명세

JPA라는 표준 덕분에 특정 구현 기술에 대한 의존도를 줄일 수 있고 다른 구현 기술로 손쉽게 이동할 수 있다는 장점

JPA 표준은 일반적이고 공통적인 기능의 모음

## JPA를 사용해야 하는 이유

- 생산성
    - 자바 컬렉션에 저장하듯이 JPA에 저장할 객체를 전달만 하면 됨
    - 데이터베이스 설계 중심의 패러다임을 객체 설계 중심으로 역전시킬 수 있음
- 유지보수
    - JPA를 사용하면 엔티티에 필드를 추가하는 일이 있을 시 수정해야하는 코드가 줄어듦
    - 따라서 유지보수해야하는 코드 수가 줄어듦
    - 패러다임의 불일치 문제를 해결해주므로 객체지향 언어가 가진 장점들을 활용해서 유연하고 유지보수하기 좋은 도메인 모델을 편리하게 설계할 수 있음
- 패러다임의 불일치 해결
    - 상속, 연관관계, 객체 그래프 탐색, 비교하기와 같은 패러다임의 불일치 문제를 해결해줌
- 성능
    - 애플리케이션과 데이터베이스 사이에서 다양한 성능 최적화 기회를 제공
- 데이터 접근 추상화와 벤더 독립성
    - 애플리케이션과 데이터베이스 사이에 추상화된 데이터 접근 계층을 제공하여 애플리케이션이 특정 데이터베이스 기술에 종속되지 않도록 함
    - 만일 데이터베이스를 변경할 시 JPA에게 다른 데이터베이스를 사용한다고 알려주기만 하면됨
- 표준
    - JPA는 자바 진영의 ORM 기술 표준이기에, 표준을 사용하면 다른 구현 기술로 손쉽게 변경 가능
