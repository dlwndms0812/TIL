- **옵티마이저**
    - 사용자가 질의한 SQL문에 대해 최적의 실행 방법을 결정하는 역할
    - 최적의 실행 방법 = **실행 계획**
    - 어떤 방법으로 처리하는 것이 동일한 일을 최소의 일량으로 처리할 수 있을 지 결정

- **옵티마이저 종류**
    - **규칙 기반 옵티마이저**
        - 우선순위 규칙에 따라 실행계획을 생성하며, 인덱스가 있으면 반드시 인덱스를 사용
    - **비용 기반 옵티마이저**
        - 처리 비용이 가장 작은 실행 계획 선택
        - 데이터 딕셔너리의 통계정보나 DBMS의 차이로 같은 쿼리도 다른 실행계획이 생성될 수 있음
        - 실행계획의 예측 및 제어가 어려움
        
- **SQL문 실행 순서**
    1. **파싱(Parsing)**
        - SQL 문법 검사 및 구문 분석 작업
    2. **실행(Execution)**
        - 옵티마이저의 실행 계획에 따라 실행
    3. **인출(Fetch)**
        - 데이터를 읽어 전송
        
- **옵티마이저 엔진**
    - **질의 변환기**
        - 사용자가 작성한 SQL 문을 처리하기 용이한 형태로 변환하는 모듈
    - **대안 계획 생성기**
        - 동일한 결과를 생성하는 다양한 대안 계획을 생성하는 모듈
        - 대안 계획의 생성이 많아지면 최적화를 수행하는 시간이 그만큼 오래 걸림
    - **비용 예측기**
        - 생성된 대안 계획의 비용을 예측하는 모듈
        
- **실행 계획**
    - SQL에서 요구한 사항을 처리하기 위한 절차와 방법
    - 다양한 실행계획(처리 방법)마다 성능(실행 시간)은 서로 다를 수 있음
    - 옵티마이저는 최적의 실행계획을 생성

- **실행 계획 구성 요소**
    - **조인 순서**
    - **조인 기법**
    - **액세스 기법**
    - **최적화 정보**
        - 실행계획의 각 단계마다 예상 비용 표시
        - **Cost**
            - 상대적인 비용 정보
        - **Card**
            - Cardinality의 약자(결과 집합의 건수)
        - **Bytes**
            - 결과 집합이 차지하는 메모리의 양
    - **연산**
        - 여러 조작을 통해 원하는 결과를 얻어내는 일련의 작업
        
- **SQL 처리 흐름도**
    - SQL의 내부적인 처리 절차를 시각적으로 표현한 도표로 실행 계획을 시각화
    - 조인 순서, 액세스 기법, 조인 기법 등 표현 가능
    - 액세스 건수, 조인 시도 건수, 테이블 액세스 건수, 성공 건수, 스캔 방식 등 표현
    
- **인덱스**
    - 검색 조건에 부합하는 데이터를 효과적으로 검색할 수 있도록 돕는 기능
    
- **인덱스 종류**
    - **트리 기반 인덱스**
    - **클러스터형 인덱스**
    
- **전체 테이블 스캔**
    - 테이블에 존재하는 모든 데이터를 읽어 가면서 조건에 맞으면 결과로 추출하고 아니면 버림
    
- **인덱스 스캔**
    - 인덱스를 구성하는 칼럼의 값을 기반으로 데이터 추출
    - 인덱스를 읽어 ROWID를 찾고 해당 데이터를 찾기 위해 테이블을 읽음
    - 일반적으로 인덱스 칼럼 순서로 정렬되어 출력
    - 적은 데이터를 조회할 때 유기
    
- **인덱스 스캔 종류**
    - 인덱스 유일 스캔
    - 인덱스 범위 스캔
    - 인덱스 역순 범위 스캔
    - 인덱스 전체 스캔
    - 인덱스 고속 전체 스캔
    - 인덱스 스킵 스캔

- **조인**
    - 두 개 이상의 테이블을 하나의 집합으로 만드는 연산
    
- **조인의 종류**
    - **NL Join**
        - 두 개의 테이블을 중첩된 반복문처럼 조인을 수행
        - 반복문 외부(처음 테이블)에 있는 테이블을 선행 테이블(외부 테이블)
        - 반복문 내부(두번째 테이블)에 있는 테이블을 후행 테이블(내부 테이블)
        - 결과 행의 수가 적은 테이블을 선행 테이블로 함
        - NL Join 절차
            1. 선행 테이블에서 조건에 맞는 값을 찾음
            2. 선행 테이블에서 조인 키를 가지고 후행 테이블 조인 키 확인
            3. 후행 테이블의 인덱스에 선행 테이블의 조인 키 존재 확인
            4. 인덱스에서 추출한 레코드 식별자(ROWID)를 이용하여 후행 테이블 액세스하여 버퍼에 저장
            5. 앞의 작업을 선행 테이블에서 만족하는 키 값이 없을 때까지 반복하여 수행
    - **Sort Merge Join**
        - 조인 칼럼을 기준으로 데이터를 정렬하여 조인
        - 넓은 범위의 데이터를 처리할 때 주로 이용
        - 인덱스를 사용하지 않아 인덱스가 존재하지 않을 경우에 사용 가능
        - Sort Merge Join 절차
            1. 선행 테이블에서 조건에 맞는 행을 찾음
            2. 선행 테이블의 조인 키를 기준으로 정렬 작업 수행
            3. 1,2 번 작업을 반복 수행하여 모든 행을 찾아 정렬
            4. 후행 테이블에서도 같은 작업을 진행
            5. 정렬된 결과를 이용하여 조인을 수행하고 결과 값을 추출 버퍼에 저장
    - **Hash Join**
        - 해싱 기법을 이용하여 조인을 수행
        - NL Join의 랜덤 액세스 문제점과 Sort Merge Join의 정렬 작업의 부담을 해결하기 위한 대안
        - 조인 칼럼의 인덱스가 존재하지 않을 경우에도 사용할 수 있음
        - =으로 수행하는 동등 조인만 가능
        - 결과 행의 수가 적은 테이블을 선행 테이블로 사용
        - Hash Join 절차
            1. 선행 테이블에서 조건에 만족하는 행을 찾음
            2. 선행 테이블의 조인 키를 기준으로 해쉬 함수를 적용하여 해쉬 테입르 생성
            3. 1,2 번을 반복하여 선행 테이블의 모든 조건에 맞는 행을 찾아 해쉬 테이블 완성
            4. 후행 테이블에서 조건에 만족하는 행을 찾음
            5. 후행 테이블의 조인 키를 기준으로 해쉬 함수를 적용하여 해당 버킷을 찾음
            6. 같은 버킷에 해당하면 조인에 성공하여 추출 버퍼에 저장
            7. 후행 테이블의 조건만큼 반복 수행하여 완료

---

**reference**

[[SQLD] 2-3. SQL 최적화 기본 원리](https://upgrade-j.tistory.com/53)
