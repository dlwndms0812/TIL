- **JOIN**
    - 두 개 이상의 테이블들을 연결 또는 결합하여 데이터를 출력
    - 일반적으로 행들은 PK나 FK 값의 연관에 의해 JOIN이 성립
    - 어떤 경우에는 PK, FK 관계가 없어도 논리적인 연관만으로 JOIN이 가능
    - n가지 테이블을 JOIN하기 위해서는 최소 n-1번의 JOIN 과정이 필요

- **EQUI JOIN**
    - 2개의 테이블 간에 칼럼값이 서로 정확하게 일치하는 경우에 사용
    - 대부분 PK, FK의 관계를 기반으로 함
    
- **NON EQUI JOIN**
    - 2개의 테이블 간에 칼럼 값들이 서로 정확하게 일치하지 않는 경우에 사용
    - = 연산자가 아닌 BETWEEN > <= 등 연산자 사용

- **일반 집합 연산자**
    - **UNION**
        - 합집합 (중복 행 제거)
    - **UNION ALL**
        - 합집합 (중복 행 포함)
    - **INTERSET**
        - 교집합
    - **EXCEPT, MINUS**
        - 차집합
    - **CARTESION PRODUCT**
        - 곱집합
        
- **순수 관계 연산자**
    - 관계형 DB를 새롭게 구현
    - **SELECT**
    - **PROJECT**
    - **JOIN**
    - **DIVIDE**

- **INNER JOIN**
    - JOIN 조건에서 동일한 값이 있는 행만 반환, USING이나 ON절을 필수적으로 사용

- **NATURAL JOIN**
    - 두 테이블 간의 동일한 이름을 갖는 모든 칼럼들에 대해 EQUI JOIN 수행
    - NATURAL JOIN이 명시되면 추가로 USING, ON, WHERE절에서 JOIN 조건 정의할 수 X
    - SQL SERVER는 지원X
    
- **USING 조건절**
    - 같은 이름을 가진 칼럼들 중에서 원하는 칼럼에 대해서만 선택적으로 EQUI JOIN
    - JOIN 칼럼에 대해서 ALIAS나 테이블 이름과 같은 접두사를 붙일 수 X
    - SQL SERVER는 지원X
    
- **ON 조건절**
    - ON 조건절과 WHERE 조건적을 분리하여 이해가 쉬우며, 칼럼명이 다르더라도 JOIN 조건을 사용할 수 있는 장점
    - ALIAS나 테이블명 반드시 사용
    
- **CROSS JOIN**
    - 양쪽 집합의 M*N건의 데이터 조합이 발생
    
- **OUTER JOIN**
    - JOIN 조건에서 동일한 값이 없는 행도 반환 가능
    - USING이나 ON 조건절 반드시 사용해야 함
    
    - **LEFT OUTER JOIN**
        - 조인 수행시 먼저 표기된 좌측 테이블에 해당하는 데이터를 읽은 후, 나중에 표기된 우측 테이블에서 JOIN 대상 데이터를 읽음
        - 우측 값에서 같은 값이 없는 경우 NULL값으로 채움
    - **RIGHT OUTER JOIN**
        - LEFT OUTER JOIN의 반대
    - **FULL OUTER JOIN**
        - 조인 수행시 좌측, 우측 테이블의 모든 데이터를 읽어 JOIN하여 결과를 생성
        - 중복 데이터는 삭제
        
- **계층형 질의**
    - 테이블에 계층형 데이터가 존재하는 경우 데이터를 조회하기 위해 사용
    - **START WITH**
        - 계층 구조 전개의 시작 위치 지정
    - **CONNECT BY**
        - 다음에 전개될 자식 데이터 지정
        - **PRIOR**
            - CONNECT BY 절에 사용되며, 현재 읽은 칼럼을 지정
            - PRIOR 자식 = 부모 형태를 사용하면 계층 구조에서 부모 데이터에서 자식 데이터 (부모 → 자식) 방향으로 전개하는 순반향 전개
    - **NOCYCLE**
        - 동일한 데이터가 전개되지 않음
    - **ORDER SIBLINGS BY**
        - 형제 노드 간의 정렬 수행
    - **WHERE**
        - 모든 전개를 수행한 후에 지정된 조건을 만족하는 데이터만 추출
    - **LEVEL**
        - 루트 데이터면 1, 그 하위 데이터면 2, 리트 데이터까지 1씩 증가
    - **CONEECT_BY_ISLEAF**
        - 해당 데이터가 리프 데이터면 1, 그렇지 않으면 0
    - **CONNECT_BY_ISCYCLE**
        - 해당 데이터가 조상이면 1, 아니면 0
    - **SYS_CONNECT_BY_PATH**
        - 루트 데이터부터 현재 전개할 데이터까지의 경로를 표시
    - **CONNECT_BY_ROOT**
        - 현재 전개할 데이터의 루트 데이터를 표시
        
- **셀프 조인**
    - 동일 테이블 사이의 조인
    - FROM 절에 동일 테이블이 2번 이상 등장
    - 반드시 테이블 별칭 사용
    
- **서브쿼리**
    - 하나의 SQL문 안에 포함되어 있는 또 다른 SQL문, 알려지지 않은 기준을 이용한 검색에 사용
    - 주의 사항
        1. 서브쿼리를 괄호로 감싸서 사용
        2. 단일 행 또는 복수행 비교 연산자와 함께 사용 가능
        단일 행 비교 연산자는 서브 쿼리의 결과가 반드시 1이하
        3. 서브쿼리에서 ORDER BY를 사용X
        4. SELECT, FROM, WHERE, HAVING, ORDER BY, INSERT-VALUEW, UPDATE-SET 절에 사용 가능
    - **단일 행 서브쿼리**
        - 서브 쿼리의 실행 결과가 항상 1건 이하인 서브쿼리
        - 단일 행 비교 연산자와 함께 사용
        - =, <, >, <=, >=, <>
    - **다중 행 서브쿼리**
        - 서브 쿼리의 실행 결과가 여러 건인 서브쿼리
        - 다중 행 비교 연산자와 함께 사용
        - IN, ALL, ANY, SOME, EXISTS
    - **다중 칼럼 서브쿼리**
        - 서브쿼리의 실행 결과로 여러 칼럼을 반환
        - 메인쿼리의 조건절에 여러 칼럼을 동시 비교
        - 서브쿼리와 메인쿼리에서 비교하고자 하는 칼럼의 개수와 칼럼의 위치가 동일해야함
    - **인라인 뷰**
        - 테이블 명이 올 수 있는 곳에 사용
        - ORDER BY 사용 가능

- **뷰**
    - 테이블은 실제로 데이터를 가지고 있는 반면, 뷰는 실제 데이터를 가지고 있지 않음
    - 사용 장점
        1. **독립성**
            - 테이블 구조가 변경되어도 뷰를 사용하는 응용프로그램은 변경X
        2. **편리성**
            - 복잡한 질의를 뷰로 생성함으로써 관견 질의를 단순하게 작성O
        3. **보안성**
            - 직원의 급여정보와 같이 숨기고 싶은 정보가 존재할 때 사용
            
- **ROLLUP**
    - Subtotal을 생성하기 위해 사용
    - Grouping Columns의 수를 N이라고 했을 때 N+1 Level의 Subtotal이 생성
    - **GROUPING**
        - Subtotal의 total을 생성
    - **CUBE**
        - 결합 가능한 모든 값에 대하야 다차원 집계를 생성
        - ROLLUP에 비해 시스템 부하 심함
    - **GROUPING SETS**
        - 인수들에 대한 개별 집계를 구할 수 있음
        
- 윈도우 함수
    - 행과 행간의 관계를 정의하거나 행과 행간을 비교, 연산하는 함수
    - OVER문구가 키워드로 필수로 포함
    - PARTITION BY 절
        - 전체 집합을 기준에 의해 소그룹으로 나눌 수 있음
    - ORDER BY 절
        - 어떤 항목에 대해 순위를 지정할 지 ORDER BY 절을 기술
    - WINDOWING 절
        - 함수의 대상이 되는 행 기준의 범위를 강력하게 지정할 수 있음
        - ROWS는 물리적인 결과 행의 수, RANGE는 논리적인 값에 의한 범위를 나타내는데, 둘 중의 하나를 선택해서 사용할 수 있음
        - SQL Server에서 지원X
    - RANK
        - 특정한 항목에 대한 순위를 구함
        - 동일한 값에 대해서는 동일한 순위를 부여 (1, 2, 2, 4)
    - DENSE_RANK
        - 동일한 순위를 하나의 등수로 간주 (1, 2, 2, 3)
    - ROW_NUMBER
        - 동일한 값이라도 고유한 순위 부여
    - SUM
        - 파티션 별 윈도우의 합
    - MAX, MIN
        - 파티션 별 윈도우의 최대, 최소값
    - AVG
        - 원하는 조건에 맞는 데이터의 통계 값
    - COUNT
        - 조건에 맞는 데이터에 대한 통계 값
    - FIRST_VALUE
        - 파티션 별 윈도우에서 가장 먼저 나온 값
        - SQL Server 지원X
    - LAST_VALUE
        - 파티션 별 윈도우에서 가장 나중에 나온 값
        - SQL Server 지원X
    - LAG
        - 파티션 별 윈도우에서 이전 몇 번째 행의 값
        - SQL Server 지원X
    - LEAD
        - 파티션 별 윈도우에서 이후 몇 번째 행의 값
        - SQL Server 지원X
    - RATIO_TO_REPORT
        - 파티션 내 전체 SUM에 대한 행 별 칼럼 값의 백분율
    - PERCENT_RANK
        - 파티션 별 윈도우에서 제일 먼저 나오는 것을 0, 제일 늦게 나오는 것을 1로 하여 행의 순서별 백분율 (0 ≤ ? ≤ 1)
    - CUME_DIST
        - 현재 행보다 작거나 같은 건수에 대한 누적백분율
    - NTILE
        - 파티션별 전체 건수를 인수 값으로 N등분
        
- **DCL**
    - 유저를 생성하고 권한을 제어할 수 있는 명령어
    - Oracle과 SQL Server의 사용자 아키텍쳐 차이
        - Oracle
            - 유저를 통해 DB에 접속을 하는 형태
            - ID와 PW 방식으로 인스턴스에 접속을 하고 그에 해당하는 스키마에 오브젝트 생성 등의 권한을 부여받음
        - SQL Server
            - 인스턴스에 접속하기 위해 로그인이라는 것을 생성하게 되며, 인스턴스 내에 존재하는 다수의 DB에 연결하여 작업하기 위해 유저를 생성한 후 로그인과 유저를 매핑해 줌
            - Windows 인증 방식과 혼합 모드 방식이 존재
    - **시스템 권한**
        - 사용자가 SQL 문을 실행하기 위해 필요한 적절한 권한
        - **GRANT**
            - 권한 부여
        - **REVOKE**
            - 권한 취소
            
- **ROLE**
    - 유저에게 알맞은 권한들을 한 번에 부여하기 위해 사용
    - **CASCADE**
        - 하위 오브젝트까지 삭제
        
- **절차형 SQL**
    - SQL문의 연속적인 실행이나 조건에 따른 분기처리를 이용하여 특정 기능을 수행하는 저장모듈을 생성할 수 있음
    - Procedure, User Define Function, Trigger….
    
- **저장 모듈**
    - PL/SQL 문장을 DB 서버에 저장하여 사용자와 애플리케이션 사이에서 공유할 수 있도록 만든 일종의 SQL 컴포넌트 프로그램
    - 독립적으로 실행되거나 다른 프로그램으로부터 실행될 수 있는 완전한 실행 프로그램
    
- **PL / SQL 특징**
    1. Block 구조로 되어있어 각 기능별로 모듈화 가능
    2. 변수, 상수 등을 선언하여 SQL 문장 간 값을 교환
    3. IF, LOOP 등의 절차형 언어를 사용하여 절차적인 프로그램이 가능하도록 함
    4. DBMS 정의 에러나 사용자 정의 에러를 정의하여 사용O
    5. Oracle에 내장되어 있어서 호환성이 좋음
    6. 응용 프로그램의 성능 향상
    7. Block 단위로 처리 → 통신량을 줄일 수 있음
    
    - **DECLARE**
        - BEGIN ~ END 절에서 사용될 변수와 인수에 대한 정의 및 데이터 타입 선언부
    - **BEGIN ~ END**
        - 개발자가 처리하고자 하는 SQL문과 여러가지 비교문, 제어문을 이용 필요한 로직 처리
    - **EXCEPTION**
        - BEGIN ~ END절에서 실행되는 SQL문이 실행될 때 에러가 발생하면, 그 에러를 어떻게 처리할 지 정의하는 예외 처리부
        
- **T-SQL**
    - 근본적으로 SQL Server를 제어하는 언어
    
- **Trigger**
    - 특정한 데이블에 INSERT, UPDATE, DELETE와 같은 DML문이 수행되었을 때, DB에서 자동으로 동작하도록 작성된 프로그램, 사용자 호출이 아닌 DB 자동 수행
    
- **프로시저와 트리거의 차이점**
    - 프로시저
        - BEGIN ~ END절 내에 COMMIT, ROLLBACK과 같은 트랜잭션 종료 명령어 사용 가능
    - 트리거
        - BEGIN ~ END 절 내에 사용 불가
        

---

**reference**

[[SQLD] 과목 2. SQL 기본 및 활용 정리](https://data-make.tistory.com/478)
