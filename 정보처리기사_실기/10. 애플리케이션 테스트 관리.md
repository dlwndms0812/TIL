# 10. 애플리케이션 테스트 관리

### Chapter 01. 애플리케이션 테스트 케이스 설계

- 애플리케이션 테스트
    - 애플리케이션에 잠재되어 있는 결함을 찾아내는 일련의 행위 또는 절차

- 애플리케이션 테스트 원리
    - 완벽한 테스팅은 불가능
        - 결함을 줄일 수는 있으나, 결함이 없다고 증명할 수 없음
    - 파레토 법칙(Pareto Principle)
        - 20%에 해당하는 코드에서 전체 결함의 80%가 발견된다는 법칙
    - 살충제 패러독스(Pesticide Paradox)
        - 동일한 테스트를 반복하명 더 이상 결함이 발견되지 않은 현상
    - 정황 의존성
        - 소프트웨어 성격에 맞게 테스트 실시
    - 오류-부재의 궤변
        - 요구사항을 충족시켜주지 못한다면, 결함이 없다고 해도 품질이 높다고 볼 수 없음
    
- 프로그램 실행 여부에 따른 분류
    - 정적 테스트
        - 테스트 대상을 실행하지 않고 구조를 분석하여 논리성을 검증하는 테스트
        - 리뷰, 정적 분석
    - 동적 테스트
        - 소프트웨어를 실행하는 방식으로 테스트를 수행하여 결함을 검출하는 테스트
            - 화이트박스 테스트, 블랙박스 테스트, 경험기반 테스트

- 화이트박스 테스트(White-Box Test)
    - 원시 코드의 논리적인 모든 경로를 테스트하여 테스트 케이스를 설계하는 방법
    - 구조 검사

- 화이트박스 테스트 유형
    - 구문(문장) 커버리지
        - 프로그램 내의 모든 명령문을 적어도 한 번 수행하는 커버리지
    - 결정(선택, 분기) 커버리지
        - 결정 포인트 내의 전체 조건식이 적어도 한 번은 참과 거짓의 결과가 되도록 수행하는 커버리지
    - 조건 커버리지
        - 결정 포인트 내의 각 개별 조건식이 적어도 한 번은 참과 거짓의 결과가 되도록 수행하는 커버리지
    - 조건/결정 커버리지
        - 전체 조건식 & 개별 조건식 모두 참 한 번, 거짓 한 번 결과가 되도록 수행하는 커버리지
    - 변경 조건/결정 커버리지
        - 개별 조건식이 다른 개별 조건식에 영향을 받지 않고 전체 조건식에 독립적으로 영향을 주도록 하는 커버리지
    - 다중 조건 커버리지
        - 결정 조건 내 모든 개별 조건식의 모든 가능한 조합을 100% 보장하는 커버리지
    - 기본 경로 커버리지
        - 수행 가능한 모든 경로를 테스트 하는 기법
    - 제어 흐름 테스트
        - 프로그램 제어 구조를 그래프 형태로 나타내어 내부 로직을 테스트하는 기법
    - 데이터 흐름 테스트
        - 제어 흐름 그래프에 사용 현황을 추가한 테스트 기법
        
- 블랙박스 테스트(Black-Box Test)
    - 사용자의 요구사항 명세를 보면서 수행하는 테스트
    - 기능 검사

- 블랙박스 테스트 유형
    - 동등 분할 테스트
        - 입력 데이터의 영역을 유사한 도메인별로 유효값/무효값을 그룹핑하여 대표값 테스트 케이스를 도출하여 테스트 하는 기법
    - 경곗값 분석 테스트
        - 입력 조건의 경계값을 테스트 케이스로 선정하여 검사하는 기법
    - 결정 테이블 테스트
        - 요구사항의 논리와 발생조건을 테이블 형태로 나열하여, 조건과 행위를 모두 조합해 테스트
    - 유스케이스 테스트
        - 유스케이스로 모델링 되어 있을 때 프로세스 흐름을 기반으로 테스트 케이스를 명세화해 수행하는 테스트
    - 분류 트리 테스트
        - SW의 일부 또는 전체를 트리구조로 분석 및 표현하여 테스트 케이스를 설계하여 테스트
    - 페어와이즈 테스트
        - 테스트 데이터 값들 간에 최소한 한 번씩 조합하는 방식
    - 원인-결과 그래프 테스트
        - 그래프를 활용해 입력 데이터 간의 관계 및 출력에 미치는 영향을 분석하여 효용성이 높은 케이스를 선정하여 테스트
    - 비교 테스트
        - 여러 버전의 프로그램에 같은 입력값을 넣어 동일한 데이터가 나오는지 비교하는 테스트
        
- 테스트 시각에 따른 분류
    - 검증(Verification)
        - 소프트웨어 개발 과정을 테스트
        - 개발자 또는 시험자의 시각
    - 확인(Validation)
        - 소프트웨어 결과를 테스트
        - 사용자 시각
        
- 테스트 목적에 따른 분류
    - 회복 테스트(Recovery Testing)
        - 시스템에 고의로 실패를 유도하고, 시스템의 정상적 복귀 여부를 테스트하는 기법
    - 안전 테스트(Security Test)
        - 불법적인 소프트웨어가 접근하여 시스템을 파괴하지 못하도록 소스 코드 내의 보안적인 결함을 미리 점검하는 테스트 기법
    - 성능 테스트(Performance Testing)
        - 시스템이 응답하는 시간, 특정 시간 내에 처리하는 업무량, 사용자 요구에서 시스템이 반응하는 속도 등을 측정하는 테스트 기법
    - 구조 테스트(Structure Testing)
        - 시스템의 내부 논리 경로, 소스 코드의 복잡도를 평가하는 테스트 기법
    - 회귀 테스트(Refression Testing)
        - 시스템의 변경 또는 수정된 코드에 새로운 결함이 없음을 확인하는 테스트
    - 병행 테스트(Parallel Testing)
        - 변경된 시스템과 기존 시스템에 동일한 데이터를 입력 후 결과를 비교하는 테스트 기법

- 성능 테스트의 상세 유형
    - 부하 테스트(Load Testing)
        - 시스템에 부가를 계속 증가시켜 시스템의 임계점을 찾는 테스트
    - 강도 테스트(Stress Testing)
        - 임계점 이상의 부하를 가하여 비정상적인 상황에서의 처리 테스트
    - 스파이크 테스트(Spike Testing)
        - 짧은 시간에 사용자가 몰릴 때 시스템의 반응 측정 테스트
    - 내구성 테스트(Endurance Testing)
        - 오랜 시간 동안 시스템에 높은 부하를 가하여 시스템 반응 테스트
    
- 테스트 종류에 따른 분류
    - 명세 기반 테스트(블랙박스 테스트)
        - 프로그램의 요구사항 명세서를 기반으로 테스트 케이스를 선정하여 테스트 하는 기법
    - 구조 기반 테스트(화이트박스 테스트)
        - 소프트웨어 내부 논리 흐름에 따라 테스트 케이스를 작성하고 확인하는 테스트 기법
    - 경험 기반 테스트(블랙박스 테스트)
        - 유사 소프트웨어나 기술 등에 대한 테스터의 경험을 기반으로 수행하는 테스트
    
- 테스트 케이스(Test Case)
    - 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위해 설계된 테스트 항복에 대한 명세서

- 테스트 오라클(Test Oracle)
    - 테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참 값을 대입하여 비교하는 기법

- 테스트 오라클 종류
    - 참(True) 오라클
        - 모든 입력값에 대하여 기대하는 결과를 제공하는 오라클
    - 샘플링(Sampling) 오라클
        - 특정한 몇 개의 입력값에 대해서만 기대하는 결과를 제공해 주는 오라클
    - 휴리스틱(Heuristic) 오라클
        - 특정 입력값에 대해 올바른 결과를 제공하고, 나머지 값들에 대해서는 추정(휴리스틱)으로 처리하는 오라클
    - 일관성 검사(Consistent) 오라클
        - 애플리케이션 변경이 있을 때, 수행 전과 후의 결과값이 동일한지 확인하는 오라클
        
- 테스트 레벨(Test Level)
    - 함계 편성되고 관리되는 테스트 활동의 그룹

- 테스트 레벨 종류
    - 단위 테스트
        - 사용자 요구사항에 대한 단위 모듈, 서브루틴 등을 테스트 하는 단계
    - 통합 테스트
        - 단위 테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트
    - 시스템 테스트
        - 개발된 소프트웨어가 정상적으로 수행되는지 검증하는 테스트
    - 인수 테스트
        - 계약상의 요구사항이 만족되었는지 확인하기 위한 테스트
    
- 소프트웨어 개발단계
    - 요구사항 → 분석 → 설계 → 구현

- 테스트 단계
    - 단위 테스트 → 통합 테스트 → 시스템 테스트 → 인수 테스트

- 인수 테스트
    - 사용자 인수 테스트
        - 사용자가 시스템 사용의 적절성 여부를 확인
    - 운영상의 인수 테스트
        - 시스템 관리자가 시스템 인수 시 수행하는 테스트 기법
    - 계약 인수 테스트
        - 계약상의 인수/검수 조건을 준수하는지 여부를 확인
    - 규정 인수 테스트
        - 소프트웨어가 정부 지침, 법규, 규정 등에 맞게 개발되었는지 확인
    - 알파 테스트
        - 개발자의 장소에서 사용자가 개발자와 함께 행하는 테스트 기법
    - 베타 테스트
        - 실제 사용자에게 대상 소프트웨어를 사용하게 하고 피드백을 받는 테스트
        
- 테스트 시나리오(Test Scenario)
    - 테스트 수행을 위한 여러 테스트 케이스의 집합, 테스트 케이스의 동작 순서를 기술한 문서이며 테스트를 위한 절차를 명세한 문서

### Chapter02. 애플리케이션 통합 테스트

- 단위 테스트(Unit Test)
    - 개별적인 모듈(또는 컴포넌트)을 테스트

- 목(Mock) 객체 생성 프레임워크
    - 객체 지향 프로그램에서는 컴포넌트 수행 시 테스트 되는 메서드는 다른 클래스의 객체에 의존하는데 이런 경우 메서드를 고립화하여 테스트하는 것이 불가는하므로 독립적인 컴포넌트 네스트를 위해서는 스텁의 객체 지향 버전인 목 객체가 필요함
    - 목 객체 유형
        - 더미 객체, 테스트 스텁, 테스트 드라이버, 테스트 스파이, 가짜 객체
    
- 통합 테스트(Intergration Test)
    - 단위 테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트

- 통합 테스트 수행 방법 간 비교
    - 빅뱅 테스트 : 모든 모듈을 동시에 통합 후 테스트 수행
        - 드라이브/스텁 : 드라이버/스텁 없이 실제 모듈로 테스트
    - 상향식 테스트 : 최하위 모듈로부터 점진적으로 상위 모듈과 함께 테스트
        - 드라이브/스텁 : 테스트 드라이버 필요
    - 하향식 테스트 : 최상위 모듈부터 하위 모듈들을 통합하면서 테스트
        - 드라이브/스텁 : 테스트 스텁 필요
    - 샌드위치 테스트 : 상위는 하향식 + 하위식 상향식 테스트
        - 드라이브/스텁 : 테스트 스텁, 드리아버 필요
    
- 테스트 자동화 도구
    - 반복적인 테스트 작업을 스크립트 형태로 구현함으로써, 테스트 시간 단축과 인력 투입 비용을 최소화하는 한편, 쉽고 효율적인 테스트를 수행할 수 잆는 방법

- 테스트 자동화 도구 유형
    - 정적 분석 도구(Static Analysis Tools)
        - 만들어진 애플리케이션을 실행하지 않고 분석하는 도구
    - 테스트 실행 도구(Test Execution Tools)
        - 테스트를 위해 작성된 스크립트를 실행하고, 스크립트 언어를 사용하여 테스트를 실행하는 도구
    - 성능 테스트 도구(Performance Test Tools)
        - 가상의 사용자를 생성하고 테스트를 수행하여 목표를 달성했는지 확인하는 도구
    - 테스트 통제 도구(Test Control Tools)
        - 테스트 계획 및 관리, 테스트 수행, 결함 관리 등을 수행하는 도구
    - 테스트 하네스 도구(Test Harness Tools)
        - 테스트가 실행될 환경을 시뮬레이션 하여 컴포넌트 및 모듈이 정상적으로 테스트되도록 하는 도구
        
- 테스트 하네스 구성요소
    - 테스트 드라이버, 테스트 스텁, 테스트 슈트, 테스트 케이스, 테스트 시나리오, 테스트 스크립트, 목 오브젝트

- 소프트웨어 결함
    - 개발자 오류로 인해 만들어지는 문서 또는 코딩 상의 결점으로 개발자가 설계한 것과 다르게 동작하거나 다른 결과가 발생하는 현상

- 테스트 결함 관리
    - 단계별 테스트 수행 후 발생한 결함의 재발 방지와 유사 결함 발견 시 처리 시간 단축을 위해 결함을 추적하고 관리하는 활동
    
- 결함 분석 방법
    - 구체화
        - 결함을 원인을 찾기 위해 결함을 발생시킨 입력값, 테스트 절차, 테스트 환경을 명확히 파악하는 방법
    - 고립화
        - 입력값, 테스트 절차, 테스트 환경 중 어떤 요소가 결함 발생에 영향을 미치는지 분석하는 방법
    - 일반화
        - 결함 발생에 영향을 주는 요소를 최대한 일반화 시키는 방법
    
- 테스트 커버리지(Test Coverage)
    - 주어진 테스트 케이스에 의해 수행되는 소프트웨어 테스트 범위를 측정하는 테스트 품질 측정 기준

- 테스트 커버리지 유형
    - 기능 기반 커버리지
        - 전체 기능을 모수로 설정하고, 실제 테스트가 수행된 기능의 수를 측정하는 방법
    - 라인 커버리지
        - 전체 소스 코드의 라인수를 모수로 테스트 시나리오가 수행한 소스 코드의 라인수를 측정하는 방법
    - 코드 커버리지
        - 소스 코드의 구문, 조건, 결정 등의 구조 코드 자체가 얼마나 테스트되었는지를 측정하는 방법
    
- 결함 심각도별 분류
    - 단순 결함(미관상 안좋음) → 경미한 결함(표준 위반) → 보통 결함(사소한 기능 오작동) → 주요 결함(기능 장애) → 치명적 결함(데이터 손실)

- 결함 우선순위
    - 낮음(Low) → 보통(Medium) → 높음(High) → 결정적(Critical)
    

### Chapter 03. 애플리케이션 성능 개선

- 애플리케이션 성능 측정 지표
    - 처리량(Throughput)
        - 애플리케이션이 주어진 시간에 처리할 수 있는 트랜잭션의 수
    - 응답 시간(Response Time)
        - 사용자 입력이 끝난 후, 애플리케이션의 응답 출력이 개시될 때까지의 시간
    - 경과 시간(Turnaround Time)
        - 애플리케이션에 사용자가 요구를 입력한 시점부터 트랜잭션을 처리 후 그 결과의 출력이 완료할 때까지 걸리는 시간
    - 자원 사용률(Resource Usage)
        - 애플리케이션이 트랜잭션을 처리하는 동안 사용하는 CPU 사용량, 메모리 사용량, 네트워크 사용량
        
- 데이터베이스 관련 성능 저하 원인
    - 데이터베이스 락(DB Lock)
        - 대량의 데이터 조회, 과도한 업데이트, 인덱스 생성 시 발생하는 현상
    - 불필요한 데이터베이스 패치(DB Fetch)
        - 실제 필요한 데이터보다 많은 대량의 데이터 요청이 들어올 경우 응답 시간 저하 현상 발생
    - 연결 누수(Connection Leak)
        - DB 연결돠 관련한 JDBC 객체를 사용 후 종료하지 않을 경우 발생
    - 부적적한 커넥션 풀 크기(Connection Pool Size)
        - 너무 작거나 크게 설정한 경우 성능 저하 현상이 발생할 가능성 존재
    - 확정(Commit) 관련
        - 트랜잭션이 확정되지 않고 커넥션 풀에 반환될 때 성능 저하 가능성 존재
    
- 배드 코드(Bad Code)
    - 프로그램 로직이 복잡하고 다른 개발자들이 이해하기 어려운 코드
    
- 배드 코드 사례
    - 외계인 코드
        - 아주 오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 아주 어려운 코드
    - 스파게티 코드
        - 소스 코드가 복잡하게 얽힌 모습
        - 정상작동하지만 코드의 작동을 파악하기 어려운 코드
    - 알 수 없는 변수명
        - 변수나 메서드에 대한 이름 정의를 알 수 없는 코드
    - 로직 중복
        - 동일한 처리 로직이 중복되게 작성된 코드
    
- 클린 코드(Clean Code)
    - 가독성이 높고, 단순하며, 의존성을 줄이고, 중복을 최소화하여 깔끔하게 잘 정리된 코드
    
- 클린 코드 특징
    - 가독성이 높아 쉽게 이해됨
    - 개선이 쉬움
    - 버그 찾기도 쉬워서 프로그래밍 속도 빨라짐
    
- 클린 코드 작성 원칙
    - 가독성
    - 단순성
    - 의존성 최소
    - 중복성 제거
    - 추상화
    
- 리팩토링(Refactoring)
    - 기능을 변경하지 않고, 복잡한 소스코드를 수정, 보완하여 가용성 및 가독성을 높이는 기법
